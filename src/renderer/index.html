<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Excel To TypeScript Converter</title>
    <style>
        .button {
            padding: 10px 20px;
            font-size: 16px;
            margin: 10px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
        }
        .button:hover {
            background-color: #45a049;
        }
        .container {
            padding: 20px;
        }
    </style>
</head>

<body>
    <div class="container">
        <button class="button" onclick="document.getElementById('fileInput').click()">
            选择Excel文件
        </button>
        <input type="file" id="fileInput" style="display: none" accept=".xlsx,.xls" />
        
        <div>
            <pre>
Output Format: <select name="format" onchange="setfmt()">
    <option value="js">TypeScript</option>
</select>

Use Web Workers when available: <input type="checkbox" name="useworker">
Always use UTF8 for CSV / text: <input type="checkbox" name="useutf8">
            </pre>
        </div>

        <pre id="out"></pre>
        <div id="htmlout"></div>
    </div>

    <script src="dist/shim.min.js"></script>
    <script src="dist/xlsx.full.min.js"></script>
    <script>
        var global_wb;
        var global_filename;

        var process_wb = (function () {
            var OUT = document.getElementById('out');

            var get_format = (function () {
                var radios = document.getElementsByName("format");
                return function () {
                    for (var i = 0; i < radios.length; ++i) if (radios[i].checked || radios.length === 1) return radios[i].value;
                };
            })();

            var to_ts = function to_ts(workbook, filename) {
                var result = {};
                var sheetName = 'Sheet1';
                if (workbook.Sheets[sheetName]) {
                    var roa = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName], { 
                        header: 1
                    });
                    if (roa.length > 2) {
                        var headers = roa[1];
                        var data = roa.slice(2).filter(row => row[0] !== undefined && row[0] !== "").map((row) => {
                            var obj = {};
                            headers.forEach((header, colIndex) => {
                                const cell = row[colIndex];
                                if (cell === undefined || cell === "") {
                                    obj[header] = null;
                                } else {
                                    const numValue = Number(cell);
                                    if (!isNaN(numValue) && !String(cell).includes("-")) {
                                        obj[header] = numValue;
                                    } else {
                                        obj[header] = cell;
                                    }
                                }
                            });
                            return obj;
                        });
                        data.forEach((item) => {
                            var key = item[headers[0]];
                            result[key] = item;
                        });
                    }
                }

                var interfaceName = filename.charAt(0).toUpperCase() + filename.slice(1) + "Data";
                var tsCode = `export interface ${interfaceName} {\n`;

                if (data.length > 0) {
                    var firstItem = data[0];
                    for (var prop in firstItem) {
                        let hasNumber = false;
                        let hasString = false;
                        data.forEach(item => {
                            if (item[prop] !== null) {
                                if (typeof item[prop] === 'number') hasNumber = true;
                                if (typeof item[prop] === 'string') hasString = true;
                            }
                        });
                        
                        let typeStr = '';
                        if (hasNumber && !hasString) typeStr = 'number';
                        else if (!hasNumber && hasString) typeStr = 'string';
                        else if (hasNumber && hasString) typeStr = 'number | string';
                        else typeStr = 'string';
                        
                        tsCode += `    ${prop}: ${typeStr} | null;\n`;
                    }
                }

                tsCode += `}\n\n`;
                tsCode += `export var ${filename}: Record<number, ${interfaceName}> = {\n`;
                for (var key in result) {
                    tsCode += `    ${key}: ${JSON.stringify(result[key]).replace(/"([^"]+)":/g, '$1:')},\n`;
                }
                tsCode += `};\n`;

                return tsCode;
            };

            return function process_wb(wb, filename) {
                global_wb = wb;
                var output = "";
                var baseFilename = filename.replace(/\.[^/.]+$/, "");
                switch (get_format()) {
                    case "js": output = to_ts(wb, baseFilename); break;
                }
                OUT.textContent = output;

                if (get_format() === "js") {
                    window.electronAPI.saveFile(output, baseFilename + ".ts")
                        .then(result => {
                            if (result.success) {
                                console.log('File saved successfully at:', result.path);
                            } else {
                                console.error('Failed to save file:', result.error);
                            }
                        })
                        .catch(err => {
                            console.error('Error saving file:', err);
                        });
                }

                if (typeof console !== 'undefined') console.log("output", new Date());
            };
        })();

        var setfmt = window.setfmt = function setfmt() { if (global_wb) process_wb(global_wb, global_filename); };

        var do_file = (function () {
            var use_worker = typeof Worker !== 'undefined';
            var domwork = document.getElementsByName("useworker")[0];
            if (!use_worker) domwork.disabled = !(domwork.checked = false);

            var use_utf8 = false;

            var xw = function xw(data, cb, filename) {
                var worker = new Worker('./xlsxworker.js');
                worker.onmessage = function (e) {
                    switch (e.data.t) {
                        case 'ready': break;
                        case 'e': console.error(e.data.d); break;
                        case 'xlsx': cb(JSON.parse(e.data.d), filename); break;
                    }
                };
                worker.postMessage({ d: data, b: 'array', c: use_utf8 ? 65001 : void 0 });
            };

            return function do_file(files) {
                use_worker = domwork.checked;
                use_utf8 = document.getElementsByName("useutf8")[0].checked;
                var f = files[0];
                global_filename = f.name;
                var reader = new FileReader();
                reader.onload = function (e) {
                    var data = new Uint8Array(e.target.result);
                    if (use_worker) xw(data, process_wb, global_filename);
                    else process_wb(XLSX.read(data, { type: 'array', codepage: use_utf8 ? 65001 : void 0 }), global_filename);
                };
                reader.readAsArrayBuffer(f);
            };
        })();

        // 添加文件输入监听
        document.getElementById('fileInput').addEventListener('change', function(e) {
            if (e.target.files.length > 0) {
                do_file(e.target.files);
            }
        });
    </script>
</body>

</html> 